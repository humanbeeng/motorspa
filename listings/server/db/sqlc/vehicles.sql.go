// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: vehicles.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const insertVehicle = `-- name: InsertVehicle :execresult
insert into vehicles (
  brand, model, date_of_purchase, kms_run, quoted_price, owner_name, owner_contact_number
) values (
?, ?, ?, ?, ?, ?, ?
)
`

type InsertVehicleParams struct {
	Brand              string    `json:"brand"`
	Model              string    `json:"model"`
	DateOfPurchase     time.Time `json:"date_of_purchase"`
	KmsRun             int32     `json:"kms_run"`
	QuotedPrice        int32     `json:"quoted_price"`
	OwnerName          string    `json:"owner_name"`
	OwnerContactNumber int32     `json:"owner_contact_number"`
}

func (q *Queries) InsertVehicle(ctx context.Context, arg InsertVehicleParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertVehicle,
		arg.Brand,
		arg.Model,
		arg.DateOfPurchase,
		arg.KmsRun,
		arg.QuotedPrice,
		arg.OwnerName,
		arg.OwnerContactNumber,
	)
}

const listVehicles = `-- name: ListVehicles :many
select id, brand, model, date_of_purchase, kms_run, owner_name, owner_contact_number, created_at, updated_at, quoted_price from vehicles
`

func (q *Queries) ListVehicles(ctx context.Context) ([]Vehicle, error) {
	rows, err := q.db.QueryContext(ctx, listVehicles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.Brand,
			&i.Model,
			&i.DateOfPurchase,
			&i.KmsRun,
			&i.OwnerName,
			&i.OwnerContactNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuotedPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
